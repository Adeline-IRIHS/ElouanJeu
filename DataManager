-- ServerScriptService/DataManager
-- Syst√®me de sauvegarde des donn√©es des joueurs - VERSION SOLIDE
-- Cr√©√© le 2025-11-16 par Adeline-IRIHS

local Players = game:GetService("Players")
local DataStoreService = game:GetService("DataStoreService")

-- DataStore
local DATASTORE_VERSION = 2 -- ‚úÖ Incr√©menter pour forcer un reset
local PlayerDataStore = DataStoreService:GetDataStore("PlayerData_v" .. DATASTORE_VERSION)

-- ‚úÖ STRUCTURE COMPL√àTE ET EXTENSIBLE
local DEFAULT_DATA = {
	-- Monnaie
	Rizz = 1000, -- Monnaie de d√©part (1000 pour tester)

	-- Base
	BaseNumber = nil, -- Quelle base il a choisi (1 √† 8, nil = aucune)
	BaseCustomization = { -- ‚úÖ NOUVEAU : Personnalisation de la base
		Walls = {
			Material = "Plastic",
			ColorR = 163,  -- ‚úÖ S√©parer Color3 en R, G, B
			ColorG = 162,
			ColorB = 165,
			Texture = nil
		},
		Floor = {
			Material = "Concrete",
			ColorR = 99,
			ColorG = 95,
			ColorB = 98,
			Texture = nil
		},
		Theme = "Default" -- Default, Dark, Light, Neon, etc.
	},

	-- Brainrots
	Brainrots = {}, -- Liste des brainrots achet√©s
	-- Chaque brainrot : {Type, SlotNumber, PriceMultiplier, BasePrice, RizzPerTick}

	-- Progression
	Floors = {1}, -- √âtages d√©bloqu√©s (commence avec Floor 1)
	Level = 1, -- ‚úÖ NOUVEAU : Niveau du joueur
	Experience = 0, -- ‚úÖ NOUVEAU : Points d'exp√©rience

	-- Statistiques
	Stats = { -- ‚úÖ NOUVEAU : Statistiques du joueur
		TotalRizzEarned = 0,
		TotalBrainrotsBought = 0,
		PlayTime = 0, -- En secondes
		JoinDate = os.time()
	},

	-- M√©tadonn√©es
	DataVersion = DATASTORE_VERSION,
	LastSave = os.time()
}

-- Donn√©es des joueurs en m√©moire
local playerData = {}

-- ‚úÖ FONCTION UTILITAIRE : Fusionner les donn√©es par d√©faut avec les donn√©es charg√©es
local function mergeWithDefaults(loadedData)
	local merged = {}

	-- Copier toutes les valeurs par d√©faut
	for key, value in pairs(DEFAULT_DATA) do
		if type(value) == "table" then
			merged[key] = {}
			for subKey, subValue in pairs(value) do
				if type(subValue) == "table" then
					merged[key][subKey] = {}
					for deepKey, deepValue in pairs(subValue) do
						merged[key][subKey][deepKey] = deepValue
					end
				else
					merged[key][subKey] = subValue
				end
			end
		else
			merged[key] = value
		end
	end

	-- √âcraser avec les donn√©es charg√©es
	if loadedData then
		for key, value in pairs(loadedData) do
			if merged[key] ~= nil then
				merged[key] = value
			end
		end
	end

	-- S'assurer que la version est √† jour
	merged.DataVersion = DATASTORE_VERSION

	return merged
end

-- ‚úÖ FONCTION UTILITAIRE : Valider les donn√©es
local function validateData(data)
	-- V√©rifier que Rizz est un nombre
	if type(data.Rizz) ~= "number" then
		data.Rizz = tonumber(data.Rizz) or DEFAULT_DATA.Rizz
	end

	-- V√©rifier que Brainrots est une table
	if type(data.Brainrots) ~= "table" then
		data.Brainrots = {}
	end

	-- V√©rifier chaque brainrot
	for i, brainrot in ipairs(data.Brainrots) do
		if type(brainrot) ~= "table" then
			table.remove(data.Brainrots, i)
			continue
		end

		-- S'assurer que les valeurs sont correctes
		brainrot.SlotNumber = tonumber(brainrot.SlotNumber) or 1
		brainrot.PriceMultiplier = tonumber(brainrot.PriceMultiplier) or 1
		brainrot.BasePrice = tonumber(brainrot.BasePrice) or 100
		brainrot.RizzPerTick = tonumber(brainrot.RizzPerTick) or 1
	end

	return data
end

-- Fonction pour charger les donn√©es d'un joueur
local function loadPlayerData(player)
	local userId = player.UserId
	local success, loadedData = pcall(function()
		return PlayerDataStore:GetAsync("Player_" .. userId)
	end)

	local data

	if success and loadedData then
		-- Fusionner avec les valeurs par d√©faut (pour ajouter de nouveaux champs)
		data = mergeWithDefaults(loadedData)
		print("‚úÖ Donn√©es charg√©es pour", player.Name)
		print("   - Rizz:", data.Rizz)
		print("   - Brainrots:", #data.Brainrots)
		print("   - Level:", data.Level)
	else
		-- Nouveau joueur ou erreur
		data = mergeWithDefaults(nil)
		if success then
			print("üÜï Nouveau joueur:", player.Name)
		else
			warn("‚ùå Erreur de chargement pour", player.Name, "- Donn√©es par d√©faut utilis√©es")
		end
	end

	-- Valider les donn√©es
	data = validateData(data)

	-- Sauvegarder en m√©moire
	playerData[userId] = data

	-- Cr√©er les leaderstats
	local leaderstats = Instance.new("Folder")
	leaderstats.Name = "leaderstats"
	leaderstats.Parent = player

	local rizzValue = Instance.new("IntValue")
	rizzValue.Name = "Rizz"
	rizzValue.Value = data.Rizz
	rizzValue.Parent = leaderstats

	local levelValue = Instance.new("IntValue")
	levelValue.Name = "Level"
	levelValue.Value = data.Level
	levelValue.Parent = leaderstats

	return data
end

-- Fonction pour sauvegarder les donn√©es d'un joueur
local function savePlayerData(player)
	local userId = player.UserId
	local data = playerData[userId]

	if not data then
		warn("‚ö†Ô∏è Aucune donn√©e √† sauvegarder pour", player.Name)
		return false
	end

	-- Mettre √† jour le timestamp
	data.LastSave = os.time()

	-- Valider avant sauvegarde
	data = validateData(data)

	-- ‚úÖ DEBUG : Afficher ce qui va √™tre sauvegard√©
	print("üíæ SAUVEGARDE pour", player.Name, ":")
	print("   - Rizz:", data.Rizz)
	print("   - BaseNumber:", data.BaseNumber)
	print("   - Brainrots:", #data.Brainrots)
	print("   - Level:", data.Level)

	-- Sauvegarder
	local success, errorMessage = pcall(function()
		PlayerDataStore:SetAsync("Player_" .. userId, data)
	end)

	if success then
		print("üíæ ‚úÖ Donn√©es sauvegard√©es pour", player.Name)
		return true
	else
		warn("‚ùå Erreur de sauvegarde pour", player.Name, ":", errorMessage)
		return false
	end
end

-- Quand un joueur rejoint
Players.PlayerAdded:Connect(function(player)
	loadPlayerData(player)
end)

-- Quand un joueur quitte
Players.PlayerRemoving:Connect(function(player)
	savePlayerData(player)
	playerData[player.UserId] = nil
end)

-- Sauvegarde automatique toutes les 5 minutes
task.spawn(function()
	while true do
		task.wait(300) -- 5 minutes
		for _, player in pairs(Players:GetPlayers()) do
			savePlayerData(player)
		end
		warn("üîÑ Sauvegarde automatique effectu√©e")
	end
end)

-- Sauvegarde avant fermeture du serveur
game:BindToClose(function()
	warn("üõë Serveur en cours de fermeture, sauvegarde de tous les joueurs...")
	for _, player in pairs(Players:GetPlayers()) do
		savePlayerData(player)
	end
	task.wait(3)
end)

-- ‚úÖ API GLOBALE COMPL√àTE ET EXTENSIBLE
_G.DataManager = {
	-- ========== DONN√âES G√âN√âRALES ==========
	GetData = function(player)
		return playerData[player.UserId]
	end,

	-- ========== RIZZ ==========
	GetRizz = function(player)
		local data = playerData[player.UserId]
		return tonumber(data and data.Rizz or 0) or 0
	end,

	AddRizz = function(player, amount)
		local data = playerData[player.UserId]
		if not data then return false end

		amount = tonumber(amount) or 0
		data.Rizz = data.Rizz + amount
		data.Stats.TotalRizzEarned = data.Stats.TotalRizzEarned + amount

		-- Mettre √† jour leaderstats
		local leaderstats = player:FindFirstChild("leaderstats")
		if leaderstats then
			local rizzValue = leaderstats:FindFirstChild("Rizz")
			if rizzValue then
				rizzValue.Value = data.Rizz
			end
		end

		return true
	end,

	RemoveRizz = function(player, amount)
		local data = playerData[player.UserId]
		amount = tonumber(amount) or 0

		if not data or data.Rizz < amount then
			return false
		end

		data.Rizz = data.Rizz - amount

		-- Mettre √† jour leaderstats
		local leaderstats = player:FindFirstChild("leaderstats")
		if leaderstats then
			local rizzValue = leaderstats:FindFirstChild("Rizz")
			if rizzValue then
				rizzValue.Value = data.Rizz
			end
		end

		return true
	end,

	-- ========== BASE ==========
	SetBase = function(player, baseNumber)
		local data = playerData[player.UserId]
		if data then
			data.BaseNumber = baseNumber
			return true
		end
		return false
	end,

	GetBase = function(player)
		local data = playerData[player.UserId]
		return data and data.BaseNumber or nil
	end,


	-- ‚úÖ NOUVEAU : Customisation de la base avec conversion Color3
	SetBaseCustomization = function(player, customizationType, property, value)
		local data = playerData[player.UserId]
		if not data then return false end

		-- customizationType = "Walls" ou "Floor"
		-- property = "Material", "Color", ou "Texture"
		if data.BaseCustomization[customizationType] then
			if property == "Color" and typeof(value) == "Color3" then
				-- Convertir Color3 en RGB s√©par√©
				data.BaseCustomization[customizationType].ColorR = math.floor(value.R * 255)
				data.BaseCustomization[customizationType].ColorG = math.floor(value.G * 255)
				data.BaseCustomization[customizationType].ColorB = math.floor(value.B * 255)
			else
				data.BaseCustomization[customizationType][property] = value
			end
			return true
		end

		return false
	end,

	-- ========== BRAINROTS ==========
	AddBrainrot = function(player, brainrotData)
		local data = playerData[player.UserId]
		if not data then return false end

		-- Nettoyer les donn√©es
		local cleanData = {
			Type = tostring(brainrotData.Type),
			SlotNumber = tonumber(brainrotData.SlotNumber),
			PriceMultiplier = tonumber(brainrotData.PriceMultiplier) or 1,
			BasePrice = tonumber(brainrotData.BasePrice) or 100,
			RizzPerTick = tonumber(brainrotData.RizzPerTick) or 1
		}

		table.insert(data.Brainrots, cleanData)
		data.Stats.TotalBrainrotsBought = data.Stats.TotalBrainrotsBought + 1

		print("‚úÖ Brainrot ajout√©:", cleanData.Type, "Slot:", cleanData.SlotNumber)
		return true
	end,

	GetBrainrots = function(player)
		local data = playerData[player.UserId]
		return data and data.Brainrots or {}
	end,

	RemoveBrainrot = function(player, slotNumber)
		local data = playerData[player.UserId]
		if not data then return false end

		for i, brainrot in ipairs(data.Brainrots) do
			if brainrot.SlotNumber == slotNumber then
				table.remove(data.Brainrots, i)
				return true
			end
		end

		return false
	end,

	-- ========== PROGRESSION ==========
	UnlockFloor = function(player, floorNumber)
		local data = playerData[player.UserId]
		if data then
			if not table.find(data.Floors, floorNumber) then
				table.insert(data.Floors, floorNumber)
				table.sort(data.Floors)
				return true
			end
		end
		return false
	end,

	GetFloors = function(player)
		local data = playerData[player.UserId]
		return data and data.Floors or {1}
	end,

	-- ‚úÖ NOUVEAU : Level et XP
	AddExperience = function(player, amount)
		local data = playerData[player.UserId]
		if not data then return false end

		data.Experience = data.Experience + amount

		-- Level up ? (100 XP par niveau)
		while data.Experience >= (data.Level * 100) do
			data.Experience = data.Experience - (data.Level * 100)
			data.Level = data.Level + 1

			-- Mettre √† jour leaderstats
			local leaderstats = player:FindFirstChild("leaderstats")
			if leaderstats then
				local levelValue = leaderstats:FindFirstChild("Level")
				if levelValue then
					levelValue.Value = data.Level
				end
			end

			print("üéâ LEVEL UP!", player.Name, "‚Üí Level", data.Level)
		end

		return true
	end,

	GetLevel = function(player)
		local data = playerData[player.UserId]
		return data and data.Level or 1
	end,

	GetExperience = function(player)
		local data = playerData[player.UserId]
		return data and data.Experience or 0
	end,

	-- ========== STATISTIQUES ==========
	GetStats = function(player)
		local data = playerData[player.UserId]
		return data and data.Stats or DEFAULT_DATA.Stats
	end,

	AddPlayTime = function(player, seconds)
		local data = playerData[player.UserId]
		if data then
			data.Stats.PlayTime = data.Stats.PlayTime + seconds
			return true
		end
		return false
	end,

	-- ========== SAUVEGARDE ==========
	SaveData = function(player)
		return savePlayerData(player)
	end,

	-- ‚úÖ NOUVEAU : Forcer un reset des donn√©es
	ResetData = function(player)
		local data = mergeWithDefaults(nil)
		playerData[player.UserId] = data
		return savePlayerData(player)
	end
}

-- ‚úÖ Tracker le temps de jeu
task.spawn(function()
	while true do
		task.wait(60) -- Toutes les minutes
		for _, player in pairs(Players:GetPlayers()) do
			_G.DataManager.AddPlayTime(player, 60)
		end
	end
end)

warn("üíæ DataManager v" .. DATASTORE_VERSION .. " initialis√© - Syst√®me solide et extensible !")
