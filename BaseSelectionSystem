-- ServerScriptService/BaseSelectionSystem
-- Syst√®me de s√©lection et gestion des bases pour les joueurs
-- Cr√©√© le 2025-11-16 par Adeline-IRIHS

local Players = game:GetService("Players")
local ServerStorage = game:GetService("ServerStorage")
local Workspace = game:GetService("Workspace")

-- Attendre que DataManager soit pr√™t
while not _G.DataManager do
	task.wait(0.5)
end

local DataManager = _G.DataManager

-- Dossiers
local baseShowroom = Workspace:WaitForChild("BaseShowroom")
local baseTemplatesFolder = ServerStorage:WaitForChild("BaseTemplates")
local brainrotTemplatesFolder = ServerStorage:WaitForChild("BrainrotTemplates")

-- Configuration
local PLATFORMS_PER_BASE = 14 -- Nombre de tables/platforms par base

-- Donn√©es des joueurs
local playerData = {}

-- ‚úÖ NOUVELLE FONCTION : Restaurer les brainrots sauvegard√©s
local function restoreSavedBrainrots(player, playerBase, platforms)
	print("üîÑ Restauration des brainrots pour", player.Name)

	-- R√©cup√©rer les brainrots sauvegard√©s
	local savedBrainrots = DataManager.GetBrainrots(player)

	if #savedBrainrots == 0 then
		print("   ‚ÑπÔ∏è Aucun brainrot √† restaurer")
		return
	end

	print("   üì¶ Brainrots √† restaurer:", #savedBrainrots)

	-- Cr√©er le dossier OwnedBrainrots s'il n'existe pas
	local ownedFolder = Workspace:FindFirstChild("OwnedBrainrots")
	if not ownedFolder then
		ownedFolder = Instance.new("Folder")
		ownedFolder.Name = "OwnedBrainrots"
		ownedFolder.Parent = Workspace
	end

	-- Restaurer chaque brainrot
	for i, brainrotData in ipairs(savedBrainrots) do
		local rarityFolder = brainrotTemplatesFolder:FindFirstChild(brainrotData.Type)

		if not rarityFolder then
			warn("   ‚ùå Raret√© introuvable:", brainrotData.Type)
			continue
		end

		-- Prendre le template avec le bon nom, ou le premier si ModelName n'existe pas
		local template = nil

		if brainrotData.ModelName then
			template = rarityFolder:FindFirstChild(brainrotData.ModelName)
		end

		if not template then
			-- Fallback : prendre le premier si le nom n'est pas trouv√©
			template = rarityFolder:FindFirstChildWhichIsA("Model")
			warn("   ‚ö†Ô∏è ModelName non trouv√©, utilisation du premier template de", brainrotData.Type)
		end


		-- Trouver la platform correspondante
		local targetPlatform = nil
		for _, platform in pairs(platforms) do
			if platform:GetAttribute("SlotNumber") == brainrotData.SlotNumber then
				targetPlatform = platform
				break
			end
		end

		if not targetPlatform then
			warn("   ‚ùå Platform Slot", brainrotData.SlotNumber, "introuvable")
			continue
		end

		-- Cloner le brainrot
		local brainrot = template:Clone()
		brainrot.Name = brainrotData.ModelName or template.Name -- ‚úÖ Garder le nom original

		-- S'assurer qu'il a un PrimaryPart
		if not brainrot.PrimaryPart then
			local rootPart = brainrot:FindFirstChild("RootPart") 
				or brainrot:FindFirstChild("FakeRootPart")
				or brainrot:FindFirstChild("Body")
				or brainrot:FindFirstChildWhichIsA("BasePart")

			if rootPart then
				brainrot.PrimaryPart = rootPart
			else
				warn("   ‚ùå Pas de PrimaryPart pour", brainrotData.Type)
				brainrot:Destroy()
				continue
			end
		end

		-- Attributs du brainrot
		brainrot:SetAttribute("Rarity", brainrotData.Type)
		brainrot:SetAttribute("Owner", player.UserId)
		brainrot:SetAttribute("OwnerName", player.Name)
		brainrot:SetAttribute("AtBase", true)
		brainrot:SetAttribute("Traveling", false)
		brainrot:SetAttribute("SlotNumber", brainrotData.SlotNumber)
		brainrot:SetAttribute("BasePrice", brainrotData.BasePrice or 100)
		brainrot:SetAttribute("CurrentPrice", (brainrotData.BasePrice or 100) * brainrotData.PriceMultiplier)
		brainrot:SetAttribute("RizzPerTick", brainrotData.RizzPerTick or 1)
		brainrot:SetAttribute("StoredRizz", 0)

		-- Positionner sur la platform
		local targetPos = targetPlatform.Position + Vector3.new(0, 1, 0)
		brainrot:PivotTo(CFrame.new(targetPos))

		-- Ancrer et rendre non-collidable
		for _, part in pairs(brainrot:GetDescendants()) do
			if part:IsA("BasePart") then
				part.Anchored = true
				part.CanCollide = false
			end
		end

		-- Marquer la platform comme occup√©e
		targetPlatform:SetAttribute("Occupied", true)
		targetPlatform:SetAttribute("BrainrotId", brainrot.Name)

		-- Parent dans OwnedBrainrots
		brainrot.Parent = ownedFolder

		print("   ‚úÖ Restaur√©:", brainrotData.Type, "sur Slot", brainrotData.SlotNumber)
	end

	print("‚úÖ Restauration termin√©e pour", player.Name)
end

-- Cr√©er la base d'un joueur √† la place du showroom
local function createPlayerBase(player, baseNumber)
	-- V√©rifier si le joueur a d√©j√† une base
	if playerData[player.UserId] then
		warn("‚ö†Ô∏è", player.Name, "a d√©j√† une base !")
		return false
	end

	local baseContainer = baseShowroom:FindFirstChild("Base" .. baseNumber)
	if not baseContainer then
		warn("‚ö†Ô∏è Base" .. baseNumber, "introuvable dans BaseShowroom")
		return false
	end

	-- Variables pour sauvegarder tous les objets du showroom
	local showroomObjects = {}
	local showroomPosition = nil
	local showroomModel = nil

	-- V√©rifier si Base est un Model directement OU un Folder contenant un Model
	if baseContainer:IsA("Model") then
		showroomModel = baseContainer
	else
		showroomModel = baseContainer:FindFirstChildWhichIsA("Model")
	end

	if showroomModel then
		-- Utiliser la position du PrimaryPart du showroom
		if showroomModel.PrimaryPart then
			showroomPosition = showroomModel:GetPrimaryPartCFrame()
		else
			-- Sinon, chercher la premi√®re BasePart du Model
			local firstPart = showroomModel:FindFirstChildWhichIsA("BasePart", true)
			if firstPart then
				showroomPosition = firstPart.CFrame
				warn("‚ö†Ô∏è PrimaryPart non d√©fini pour Base" .. baseNumber)
			end
		end
	end

	-- Si toujours pas trouv√©, chercher n'importe quelle Part dans le container
	if not showroomPosition then
		local firstPart = baseContainer:FindFirstChildWhichIsA("BasePart", true)
		if firstPart then
			showroomPosition = firstPart.CFrame
		end
	end

	if not showroomPosition then
		warn("‚ö†Ô∏è Impossible de d√©terminer la position de Base" .. baseNumber)
		return false
	end

	-- MASQUER tous les objets du showroom
	for _, child in pairs(baseContainer:GetDescendants()) do
		if child:IsA("BasePart") then
			child:SetAttribute("OriginalTransparency", child.Transparency)
			child:SetAttribute("OriginalCanCollide", child.CanCollide)
			child.Transparency = 1
			child.CanCollide = false
			table.insert(showroomObjects, child)
		elseif child:IsA("Decal") or child:IsA("Texture") then
			child:SetAttribute("OriginalTransparency", child.Transparency)
			child.Transparency = 1
			table.insert(showroomObjects, child)
		elseif child:IsA("SurfaceGui") or child:IsA("BillboardGui") then
			child:SetAttribute("OriginalEnabled", child.Enabled)
			child.Enabled = false
			table.insert(showroomObjects, child)
		end
	end

	-- R√©cup√©rer le template
	local baseTemplate = baseTemplatesFolder:FindFirstChild("Base" .. baseNumber)
	if not baseTemplate then
		warn("‚ö†Ô∏è Template Base" .. baseNumber, "introuvable dans ServerStorage")
		return false
	end

	-- Cloner la base du joueur
	local playerBase = baseTemplate:Clone()
	playerBase.Name = player.Name .. "_Base"

	-- Attributs
	playerBase:SetAttribute("Owner", player.UserId)
	playerBase:SetAttribute("OwnerName", player.Name)
	playerBase:SetAttribute("BaseNumber", baseNumber)

	-- Positionner √† la place du showroom avec rotation de 90¬∞ √† gauche
	if playerBase.PrimaryPart then
		local rotatedCFrame = showroomPosition
		playerBase:SetPrimaryPartCFrame(rotatedCFrame)
	else
		warn("‚ö†Ô∏è PrimaryPart non d√©fini pour la base du joueur")
		playerBase:MoveTo(showroomPosition.Position)
	end

	-- Parent : si c'√©tait un Model, mettre √† c√¥t√©, sinon dans le Folder
	if baseContainer:IsA("Model") then
		playerBase.Parent = baseContainer.Parent
	else
		playerBase.Parent = baseContainer
	end

	-- TROUVER ET CONFIGURER LES PLATFORMS EXISTANTES
	local tableFolder = playerBase:FindFirstChild("Table")
	local platforms = {}

	if tableFolder then
		for i = 1, PLATFORMS_PER_BASE do
			local tableX = tableFolder:FindFirstChild("Table" .. i)
			if tableX then
				-- Table1, Table2... sont des Models
				-- Chercher le Part "Platform" (avec P majuscule) √† l'int√©rieur
				local platform = tableX:FindFirstChild("Platform", true) -- true = cherche dans les descendants

				-- V√©rifier que c'est bien une BasePart
				if platform and platform:IsA("BasePart") then
					-- Configurer la platform pour √™tre un slot
					platform:SetAttribute("SlotNumber", i)
					platform:SetAttribute("Occupied", false)
					platform:SetAttribute("BrainrotId", nil)

					table.insert(platforms, platform)
				else
					warn("‚ö†Ô∏è Platform (Part) introuvable dans Table" .. i)
				end
			else
				warn("‚ö†Ô∏è Table" .. i, "introuvable dans la base du joueur")
			end
		end
	else
		warn("‚ö†Ô∏è Folder 'Table' introuvable dans la base du joueur")
	end

	-- Sauvegarder les donn√©es
	playerData[player.UserId] = {
		Base = playerBase,
		BaseNumber = baseNumber,
		Platforms = platforms,
		Slots = {},
		ShowroomObjects = showroomObjects,
		Brainrots = {}
	}

	-- ‚úÖ RESTAURER LES BRAINROTS SAUVEGARD√âS
	restoreSavedBrainrots(player, playerBase, platforms)

	-- ‚úÖ SAUVEGARDER LA BASE DANS LE DATAMANAGER
	DataManager.SetBase(player, baseNumber)

	return true
end

-- Restaurer le showroom quand un joueur part
local function restoreShowroom(player)
	local data = playerData[player.UserId]
	if not data then return end

	-- D√©truire la base du joueur
	if data.Base then
		data.Base:Destroy()
	end

	-- RESTAURER tous les objets du showroom
	if data.ShowroomObjects then
		for _, obj in pairs(data.ShowroomObjects) do
			if not obj or not obj.Parent then continue end

			if obj:IsA("BasePart") then
				local originalTransparency = obj:GetAttribute("OriginalTransparency") or 0
				local originalCanCollide = obj:GetAttribute("OriginalCanCollide")
				if originalCanCollide ~= nil then
					obj.CanCollide = originalCanCollide
				end
				obj.Transparency = originalTransparency
			elseif obj:IsA("Decal") or obj:IsA("Texture") then
				local originalTransparency = obj:GetAttribute("OriginalTransparency") or 0
				obj.Transparency = originalTransparency
			elseif obj:IsA("SurfaceGui") or obj:IsA("BillboardGui") then
				local originalEnabled = obj:GetAttribute("OriginalEnabled")
				if originalEnabled ~= nil then
					obj.Enabled = originalEnabled
				end
			end
		end
	end

	playerData[player.UserId] = nil
end

-- Configurer les boutons du showroom
local function setupShowroomButtons()
	for i = 1, 8 do
		local baseContainer = baseShowroom:FindFirstChild("Base" .. i)
		if not baseContainer then
			warn("‚ö†Ô∏è Base" .. i, "introuvable dans BaseShowroom")
			continue
		end

		-- Chercher le ClaimButton (dans Model OU Folder)
		local button = baseContainer:FindFirstChild("ClaimButton", true)

		if not button then
			warn("‚ö†Ô∏è ClaimButton introuvable dans Base" .. i)
			continue
		end

		-- D√©bounce par joueur
		local debounce = {}

		-- √âv√©nement Touched
		button.Touched:Connect(function(hit)
			local character = hit.Parent
			local humanoid = character:FindFirstChildOfClass("Humanoid")
			if not humanoid then return end

			local player = Players:GetPlayerFromCharacter(character)
			if not player then return end

			if debounce[player.UserId] then return end
			debounce[player.UserId] = true

			-- V√©rifier si le joueur a d√©j√† une base
			if playerData[player.UserId] then
				warn("‚ö†Ô∏è", player.Name, "a d√©j√† une base")
				task.delay(2, function()
					debounce[player.UserId] = nil
				end)
				return
			end

			-- Cr√©er la base
			createPlayerBase(player, i)

			task.delay(2, function()
				debounce[player.UserId] = nil
			end)
		end)
	end
end

-- ‚úÖ NOUVEAU : V√©rifier si le joueur avait d√©j√† une base et la recr√©er
Players.PlayerAdded:Connect(function(player)
	-- Attendre un peu que DataManager charge les donn√©es
	task.wait(1)

	local savedBaseNumber = DataManager.GetBase(player)

	if savedBaseNumber then
		print("üè† Restauration de la base", savedBaseNumber, "pour", player.Name)
		createPlayerBase(player, savedBaseNumber)
	else
		print("‚ÑπÔ∏è", player.Name, "n'a pas encore de base")
	end
end)

-- Quand un joueur quitte
Players.PlayerRemoving:Connect(function(player)
	restoreShowroom(player)
end)

-- Initialisation
setupShowroomButtons()

-- Fonctions globales accessibles par d'autres scripts
_G.BaseManager = {
	-- Obtenir la base d'un joueur
	GetPlayerBase = function(player)
		local data = playerData[player.UserId]
		return data and data.Base or nil
	end,

	-- Obtenir toutes les donn√©es d'un joueur
	GetPlayerData = function(player)
		return playerData[player.UserId]
	end,

	-- Obtenir une platform libre dans la base d'un joueur
	GetFreePlatform = function(player)
		local data = playerData[player.UserId]
		if not data then return nil end

		for _, platform in pairs(data.Platforms) do
			if not platform:GetAttribute("Occupied") then
				return platform
			end
		end

		return nil
	end,

	-- Marquer une platform comme occup√©e
	OccupyPlatform = function(platform, brainrotId)
		if platform then
			platform:SetAttribute("Occupied", true)
			platform:SetAttribute("BrainrotId", brainrotId)
			return true
		end
		return false
	end,

	-- Lib√©rer une platform
	FreePlatform = function(platform)
		if platform then
			platform:SetAttribute("Occupied", false)
			platform:SetAttribute("BrainrotId", nil)
			return true
		end
		return false
	end,

	-- Obtenir le nombre de platforms disponibles
	GetAvailablePlatformCount = function(player)
		local data = playerData[player.UserId]
		if not data then return 0 end

		local count = 0
		for _, platform in pairs(data.Platforms) do
			if not platform:GetAttribute("Occupied") then
				count = count + 1
			end
		end

		return count
	end
}

print("‚úÖ BaseManager initialis√© avec syst√®me de restauration")
